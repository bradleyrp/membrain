#!/usr/bin/python

from scipy.optimize import leastsq

qrange = [0.01,0.3]

cgmd_names = [analysis_descriptors[key]['testname'] 
	for key in analysis_descriptors.keys() if analysis_descriptors[key]['simtype']=='md']

def kappafits(scalefac):	
	subj = master_spectrum_dict[key]
	t2d = subj['cgmd_t2d']
	qmagst = subj['cgmd_qs']
	tsum2d = scalefac*(t2d[0]*qmagst**4-t2d[1]*qmagst**2-
		t2d[2]*qmagst**2+t2d[3])
	xdat = collapse_spectrum(qmagst,qmagst)
	ydat = collapse_spectrum(qmagst,tsum2d)
	#---target is global and shot is local, computed from the key each time
	#---? possibly very inefficient
	shot = array([xdat,ydat]).T
	if 0:
		#---screwed up!!!!!!!!!!!!!!!!!!!!!!!!!
		#---residual computation
		orders = [list(scipy.spatial.distance.cdist(
			[[i] for i in target.T[0]],[[i] for i in shot.T[0]]).argmin(axis=j)) for j in range(2)]
		inputs = [array([i for i in shot if i[0] < qrange[1] and i[0] > qrange[0]]),
			array([i for i in target if i[0] < qrange[1] and i[0] > qrange[0]])]
		if len(orders[0]) >= len(orders[1]): resid = sum((inputs[0].T[1]-inputs[1].T[1][orders[0]])**2)
		else: resid = sum((inputs[0].T[1][orders[1]]-inputs[1].T[1])**2)
		return resid
	inputs = [array([i for i in shot if i[0] < qrange[1] and i[0] > qrange[0]]),
		array([i for i in target if i[0] < qrange[1] and i[0] > qrange[0]])]
	return (mean(inputs[0].T[1])-mean(inputs[1].T[1]))**2


#---plotting just the undulations
if 0:
	fig = plt.figure()
	ax = plt.subplot(111)
	for key in [i for i in master_spectrum_dict.keys() if i in analysis_descriptors.keys()]:
		status('status: plotting key = '+key)
		subj = master_spectrum_dict[key]
		if 'meso_qs' in subj.keys():
			xdat = collapse_spectrum(subj['meso_qs'],subj['meso_qs'])
			ydat = collapse_spectrum(subj['meso_qs'],subj['meso_t2d'][0])
		elif 'cgmd_qs' in subj.keys():
			xdat = collapse_spectrum(subj['cgmd_qs'],subj['cgmd_qs'])
			ydat = collapse_spectrum(subj['cgmd_qs'],subj['cgmd_t2d'][0])
		if (analysis_descriptors[key])['simtype'] == 'meso':
			color = 'k'
			alpha = 0.35
			zorder = 1
			lw = 1
			label = ''
			kappa_app = analysis_descriptors[key]['kappa_apparent']
		else:
			color = clrs[cgmd_names.index(analysis_descriptors[key]['testname'])]
			alpha = 1.0
			zorder = 2
			lw = 3
			label = analysis_descriptors[key]['label']
			kappa_app = 25.
		inds = argsort(array(xdat)**4)
	
		ax.plot(
			array(xdat)[inds]**4,array(ydat)[inds]*array(xdat)[inds]**4/kappa_app,
			color=color,alpha=alpha,zorder=zorder,lw=lw,label=label)
	ax.set_xscale('log')
	ax.set_yscale('log')
	h,l = ax.get_legend_handles_labels()
	h = [h[i] for i in range(len(l)) if l[i] != '']
	l = [l[i] for i in range(len(l)) if l[i] != '']
	ax.legend(h[::-1],l[::-1],loc='upper left')
	plt.show()

#---plotting the energy terms
if 1 or 'mesospec_collect' not in globals():

	mesospec_collect = []
	mesospec_collect_q = []
	meso_kappas = []
	cgmd_collect = []
	cgmd_collect_q = []
	cgmd_keys = []
	

	fig = plt.figure()
	axes = []
	ax = plt.subplot(211)
	ax2 = plt.subplot(212)
	axes.append(ax)
	axes.append(ax2)
	for key in [i for i in master_spectrum_dict.keys() if i in analysis_descriptors.keys()]:
		status('status: plotting key = '+key)
		subj = master_spectrum_dict[key]
		
		scalefac = 1.
		if 'meso_qs' in subj.keys():
			t2d = subj['meso_t2d']
			qmagst = subj['meso_qs']
		elif 'cgmd_qs' in subj.keys():
			t2d = subj['cgmd_t2d']
			qmagst = subj['cgmd_qs']
		tsum2d = scalefac*(t2d[0]*qmagst**4-t2d[1]*qmagst**2-
			t2d[2]*qmagst**2+t2d[3])
		xdat = collapse_spectrum(qmagst,qmagst)
		ydat = collapse_spectrum(qmagst,tsum2d)
		
		if 'meso_qs' in subj.keys(): mesospec_collect.append(ydat),mesospec_collect_q.append(xdat)
		if 'cgmd_qs' in subj.keys(): 
			cgmd_collect.append(ydat)
			cgmd_collect_q.append(xdat)
			cgmd_keys.append(key)
		
		if (analysis_descriptors[key])['simtype'] == 'meso':
			color = 'k'
			alpha = 0.35
			zorder = 1
			lw = 1
			label = ''
			kappa_app = analysis_descriptors[key]['kappa_apparent']
		else:
			color = clrs[cgmd_names.index(analysis_descriptors[key]['testname'])]
			alpha = 0.2
			zorder = 2
			lw = 3
			label = analysis_descriptors[key]['label']
			mset = unpickle(pickles+analysis_descriptors[key]['locate'])
			kappa_app = mset.undulate_kappa
			print key+' kappa_apparent = '+str(kappa_app)
		meso_kappas.append(kappa_app)
		inds = argsort(array(xdat))
		
		#---CRITICAL PORTION OF THE CALCULATION
		'''
		Plan for each of the 1d kBT-equivalent spectra
			1. Choose a wavevector range to study
			2. Take the average of all mesoscale simulations, nearly equal (after kappa adjustment). 
			3. Then compute the supposed kappa for the CGMD simulations
			4. Then find the best fit to curvature
			5. Bask in the glory of a nice two-parameter fit?
		'''
		
		ax.plot(array(xdat)[inds],array(ydat)[inds]*kappa_app,
			color=color,alpha=alpha,zorder=zorder,lw=lw,label=label)

		tsum2d = scalefac*(t2d[0]*qmagst**4)
		xdat = collapse_spectrum(qmagst,qmagst)
		ydat = collapse_spectrum(qmagst,tsum2d)

		ax2.plot(array(xdat)[inds],array(ydat)[inds]*kappa_app,
			color=color,alpha=alpha,zorder=zorder,lw=lw,label=label)
	
	ax.plot(mean(mesospec_collect_q,axis=0),mean(mesospec_collect,axis=0)*mean(meso_kappas),'k-',lw=4)
			
	for ax in axes:
		ax.axvline(x=0.4,ymin=0,ymax=1.,lw=2,c='r',alpha=0.5,zorder=0)
		ax.set_xscale('log')
		ax.set_yscale('log')
		h,l = ax.get_legend_handles_labels()
		h = [h[i] for i in range(len(l)) if l[i] != '']
		l = [l[i] for i in range(len(l)) if l[i] != '']
		ax.legend(h[::-1],l[::-1],loc='upper left')
	
	ax = axes[0]
	cgmd_keys = [key for key in analysis_descriptors.keys() if analysis_descriptors[key]['simtype'] == 'md']
	#---ACTUAL FITS
	for cnum in range(len(cgmd_keys)):
		key = cgmd_keys[cnum]
		bigref = array([mean(mesospec_collect_q,axis=0),mean(mesospec_collect,axis=0)*mean(meso_kappas)]).T
		target = bigref
		print 'optimizing'
		p_opt = leastsq(kappafits,1.)

		subj = master_spectrum_dict[key]
		scalefac = p_opt[0][0]
		print key+' scalefac = '+str(scalefac)
		t2d = subj['cgmd_t2d']
		qmagst = subj['cgmd_qs']
		tsum2d = scalefac*(t2d[0]*qmagst**4-t2d[1]*qmagst**2-
			t2d[2]*qmagst**2+t2d[3])
		xdat = collapse_spectrum(qmagst,qmagst)
		ydat = collapse_spectrum(qmagst,tsum2d)	
		color = clrs[cnum]
		alpha = 1.0
		zorder = 2
		lw = 3
		label = analysis_descriptors[key]['label']
		ax.plot(array(xdat)[inds],array(ydat)[inds],'-',
			color=color,alpha=alpha,zorder=zorder,lw=lw,label=label)
	
	
	plt.show()
'''
def generic_residual(inputs,ordering):
	if len(ordering[0]) >= len(ordering[1]): return sum((inputs[0].T[1]-inputs[1].T[1][ordering[0]])**2)
	else: return sum((inputs[0].T[1][ordering[1]]-inputs[1].T[1])**2)


if 1:
	#---generate appropriate ordering for residual function
	orders = [list(scipy.spatial.distance.cdist(
		[[i] for i in target.T[0]],[[i] for i in shot.T[0]]).argmin(axis=j)) for j in range(2)]
	#---must reverse shot and target from the written order seen in the defn of orders above
	print generic_residual([shot,target],orders)
	
	#p_opt = leastsq(residfunc,array([0,0,target_com[0],target_com[0],50,50,0])
	#generic_residual


if 0:	
	meanqs = mean(mesospec_collect_q,axis=0)
	inds = [list(where(1*(array(i)>0.4)+1*(array(i)<1.0)==2)[0]) for i in mesospec_collect_q]
	meanydat = mean([mesospec_collect[l][i] for l in range(len(inds)) for i in inds[l]])
	#---confirm that the indices are monotone
	if 0:
		for i in range(len(inds)): plt.plot(range(len(inds[i])),array(mesospec_collect_q[i])[inds[i]])
		plt.show()

	#---example curvfit operation	
	target = array([mesospec_collect_q[0],mesospec_collect[0]]).T
	shot = array([cgmd_collect_q[0],cgmd_collect[0]]).T

	#---fast way to do the ordering
	ordering = list(scipy.spatial.distance.cdist(
		[[i] for i in target.T[0]],[[i] for i in shot.T[0]]).argmin(axis=0))
	print generic_residual(target,shot,ordering)
		
if 1:
	#---regenerate kappas
	cgmd_keys = [key for key in analysis_descriptors.keys() if analysis_descriptors[key]['simtype'] == 'md']
	key = cgmd_keys[0]
	bigref = array([mean(mesospec_collect_q,axis=0),mean(mesospec_collect,axis=0)*mean(meso_kappas)]).T
	target = bigref
	
p_opt = leastsq(kappafits,1.)
'''	
	
	
	
